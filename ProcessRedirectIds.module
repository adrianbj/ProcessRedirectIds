<?php

/**
 * ProcessWire Redirect ID based URLs
 * by Adrian Jones
 *
 * Automatically redirects ID based URL to full SEO friendly URL
 *
 * ProcessWire 2.x
 * Copyright (C) 2011 by Ryan Cramer
 * Licensed under GNU/GPL v2, see LICENSE.TXT
 *
 * http://www.processwire.com
 * http://www.ryancramer.com
 *
 */

class ProcessRedirectIds extends WireData implements Module, ConfigurableModule {

	public static function getModuleInfo() {
		return array(
			'title' => 'Redirect ID based URLs',
			'summary' => 'Redirects ID based URL to full SEO friendly URL',
			'href' => 'http://processwire.com/talk/topic/4611-redirect-id-based-urls/',
			'version' => 20,
			'permanent' => false,
			'autoload' => true,
			'singular' => true
		);
	}


    /**
     * Data as used by the get/set functions
     *
     */
    protected $data = array();


   /**
     * Default configuration for module
     *
     */
    static public function getDefaultData() {
            return array(
                "redirectType" => "Redirect",
                "enabledFields" => "",
                "enabledTemplates" => ""
            );
    }

    /**
     * Populate the default config data
     *
     */
    public function __construct() {
       foreach(self::getDefaultData() as $key => $value) {
               $this->$key = $value;
       }
    }


	public function init() {
		$this->addHookAfter('ProcessPageView::pageNotFound', $this, 'redirectIds', array('priority'=>10000));
	}


	public function ready() {

		// we're interested in page editor only
		if(wire('page')->process != 'ProcessPageEdit') return;

		// skip changing templates (only target the actual edit form)
		$id = (int)$this->input->get->id;
		if(!$id) return;

		// wire('page') would be the page with ProcessPageEdit
		// GET parameter id tells the page that's being edited
		$this->editedPage = wire('pages')->get($id);


		// don't even consider system templates
		if($this->editedPage->template->flags & Template::flagSystem) return;


		// hook only if
		// 1) no templates or pages have been chosen (=all) OR
		// 2) the template of the edited page has been chosen or the page or a parent page of the edited page has been chosen

		if($this->editedPage->id != 1){
			foreach(explode("|",$this->editedPage->parents) as $parent){
				$parentEnabled = in_array($parent, $this->data['enabledPages']) ? true : false;
			}

			if((count($this->data['enabledTemplates']) == 0 || in_array($this->editedPage->template->name, $this->data['enabledTemplates'])) &&
			(count($this->data['enabledPages']) == 0 || in_array($this->editedPage->id, $this->data['enabledPages'])) || $parentEnabled) {
				$this->addHookAfter('ProcessPageEdit::buildForm', $this, 'addShortURLLinks');
			}
		}
	}


	public function redirectIds($event) {

		// determine the URL that wasn't found
		$url = $_SERVER['REQUEST_URI'];

		// if installed in a subdirectory, make $url relative to the directory ProcessWire is installed in
		if($this->config->urls->root != '/') {
			$url = substr($url, strlen($this->config->urls->root)-1);
		}

		foreach(explode('/', $url) as $part){
			$part = preg_replace("/[^0-9]/", "", $part);
			if(is_numeric($part)) $id = (int) $part;
		}


		// if there is an ID in the URL
		if(isset($id) && $id!=''){

			$p = $this->pages->get($id);

			// if there is a page match, then proceed to check if templates and pages configuration allows the redirect
			if($p->id && $p->id >= 1000 && $p->parent->id != 2 && $p->viewable()){

				foreach(explode("|", $p->parents) as $parent){
					$parentEnabled = in_array($parent, $this->data['enabledPages']) ? true : false;
				}

				if((count($this->data['enabledTemplates']) == 0 || in_array($p->template->name, $this->data['enabledTemplates'])) &&
				(count($this->data['enabledPages']) == 0 || in_array($p->id, $this->data['enabledPages'])) || $parentEnabled) {

					if($this->data['redirectType']=='Load'){
						header("HTTP/1.1 200 OK");
						$event->return = str_replace("<head>","<head>\n\n\t<link href='$p->httpUrl' rel='canonical' />",$this->pages->get($p->path)->render());
					}
					else{
						$this->session->redirect($p->path);
					}

				}
			}
		}
	}

	public function addShortURLLinks(HookEvent $event){
		$current_page = $this->pages->get((int) $this->input->get->id);

		$form = $event->return;

		$shortlinks = '';

		// create the tab
		$refTab = new InputfieldWrapper();
		$refTab->attr('id', $this->className() . 'ShortLinks');
		$refTab->attr('title', $this->_('ShortLinks'));

		// construct contents inside a container
		$field = $this->modules->get("InputfieldMarkup");
		$field->label = $this->_("List of example shortlinks that can be used to access this page");
		$field->description = $this->_("You can define any URL you want, so long as the page ID ({$current_page->id}) is in the URL somewhere.");
		$field->notes = $this->_("The last two examples are longer than the default title and therefore might seem strange, but their advantage is that if the page is ever renamed, or moved to different parents, these links will still work, as will any of the other options listed here.");

		$shortlinks .= "<p><a href='http://{$_SERVER['HTTP_HOST']}/{$current_page->id}/' target='_blank'>http://{$_SERVER['HTTP_HOST']}/{$current_page->id}/</a></p>";
		if($current_page->parent->id !=1) $shortlinks .= "<p><a href='http://{$_SERVER['HTTP_HOST']}{$current_page->parent->path}{$current_page->id}/' target='_blank'>http://{$_SERVER['HTTP_HOST']}{$current_page->parent->path}{$current_page->id}/</a></p>";
		$shortlinks .= "<p><a href='http://{$_SERVER['HTTP_HOST']}/{$current_page->id}{$current_page->path}' target='_blank'>http://{$_SERVER['HTTP_HOST']}/{$current_page->id}{$current_page->path}</a></p>";
		$shortlinks .= "<p><a href='http://{$_SERVER['HTTP_HOST']}".rtrim($current_page->path, '/')."-{$current_page->id}/' target='_blank'>http://{$_SERVER['HTTP_HOST']}".rtrim($current_page->path, '/')."-{$current_page->id}/</a></p>";

		$field->value = $shortlinks;

		// append the markup to the tab and the tab to the form
		$refTab->append($field);
		$form->append($refTab);

	}


	/**
	 * Return an InputfieldsWrapper of Inputfields used to configure the class
	 *
	 * @param array $data Array of config values indexed by field name
	 * @return InputfieldsWrapper
	 *
	 */
	public static function getModuleConfigInputfields(array $data) {

		$data = array_merge(self::getDefaultData(), $data);

		$wrapper = new InputFieldWrapper();

		$redirectType = wire('modules')->get('InputfieldSelect');
		$redirectType->attr('name+id', 'redirectType');
		$redirectType->label = __('Redirect Type', __FILE__);
		$redirectType->description = __('The default is to redirect to the original PW url for the page, but if you prefer you can change this setting to "Load" to have it keep the ID based URL as entered and simply load the page content.', __FILE__);
		$redirectType->addOption("Redirect");
		$redirectType->addOption("Load");

		if(isset($data['redirectType'])) $redirectType->value = $data['redirectType'];

		$wrapper->add($redirectType);


		$fieldEnabledTemplates = wire('modules')->get('InputfieldAsmSelect');
		$fieldEnabledTemplates->attr('name+id', 'enabledTemplates');
		$fieldEnabledTemplates->label = __('Enabled templates', __FILE__);
		$fieldEnabledTemplates->description = __('ID based shortlinks will only work for the selected templates. If no templates are chosen, the links will work for all templates.', __FILE__);
		$fieldEnabledTemplates->setAsmSelectOption('sortable', false);

		// populate with all available templates
		foreach(wire('templates') as $t) {
			// filter out system templates
			if(!($t->flags & Template::flagSystem)) $fieldEnabledTemplates->addOption($t->name);
		}

		if(isset($data['enabledTemplates'])) $fieldEnabledTemplates->value = $data['enabledTemplates'];

		$wrapper->add($fieldEnabledTemplates);


		$fieldEnabledPages = wire('modules')->get('InputfieldPageListSelectMultiple');
		$fieldEnabledPages->attr('name+id', 'enabledPages');
		$fieldEnabledPages->label = __('Enabled pages', __FILE__);
		$fieldEnabledPages->description = __('ID based shortlinks will only work for the selected pages and their children. If no pages are chosen, the links will work for all pages, except admin and other pages that are not viewable to the user.', __FILE__);
		$fieldEnabledPages->attr('title', __('Enable page', __FILE__));

		if(isset($data['enabledPages'])) $fieldEnabledPages->value = $data['enabledPages'];

		$wrapper->add($fieldEnabledPages);


		return $wrapper;
	}
}